* Почему SC?
Supercollider - это швейцарский нож для работы со звуком и композиции.
С его помощью можно создавать программные синтезаторы, использовать его для
генеративной/алгоритмической музыки, создавать языки и среды для лайв-кодинга,
генерировать MIDI и посылать в любимую DAW и так далее.

* Архитектура
Сама среда состоит из сервера (Scsynth или SuperNova) и языка (Sclang). Язык
и сервер общаются с помощью протокола [[https://en.wikipedia.org/wiki/Open_Sound_Control][OSC]]. Именно эта особенность делает
возможным быстро и довольно просто создавать интерфейсы для Scsynth на других
языках программирования или использовать его в других программах, например
[[https://tidalcycles.org/index.php/Welcome][Tidal Cycles]] - невероятно популярной среде для лайв кодинга.

Кроме того такая архитектура позволяет синхронизировать выступление нескольких
человек. Именно так делают [[http://www.the-mandelbrots.de/][Benoît and the Mandelbrots]]

* Базовый синтаксис
Все инструкции языка разделяются символом ';'. Существует только одно
исключение - код, состоящий из одной строки, но вряд ли такой код может быть
полезен.

Код из примера ниже выведет строку на экран:

#+begin_src sclang
"Hello World!".postln;
#+end_src

Иногда удобно группировать инструкции языка, чтобы выполнить несколько действий
последовательно. Для этого инструкции заключаются в скобки:

#+begin_src sclang
(
"Hello World!".postln;
"Hello SC Workshop!".postln;
)
#+end_src

* Переменные
В SC существует три типа переменных: обычные переменные, глобальные и переменные
окружения.

Обычные переменные обозначаются ключевым словом ~var~. Такие переменные могут
существовать только в пределах блоков кода или функции (о них поговорим позже).

Такой код выведет строку "nothing" на экран:

#+begin_src sclang
(
var something = "nothing";
something.postln;
)
#+end_src

При этом такой код завершиться с ошибкой:

#+begin_src sclang
(
var something = "nothing";
)

something.postln;
#+end_src

Так как за пределами скобок переменная уже не существует.

Переменные можно объявлять через запятую:
#+begin_src sclang
(
var something, meaning_of_life;
something = "nothing";
meaning_of_life = 42;
)
#+end_src

Также существуют глобальные переменные - это все символы латинского алфавита,
кроме ~s~ - этот символ зарезервирован и является ссылкой на экземпляр сервера.
Глобальные переменные существуют независимо от блоков кода.

#+begin_src sclang
a = 0;
 
(
a = 1 + 1;
)

a.postln; // 2
#+end_src

Переменные окружения начинаются с символа ~, например =~something=.

* Функции

Функции - крайне важная тема в любом языке программирования. Они позволяют
выполнять часто повторяемые операции или производить вычисления, зависимые
от передаваемых параметров.

Чтобы создать функцию нужно заключить выражение в фигурные скобки, при этом
функция вернёт последнее выражение.

Чтобы вызвать функцию необходимо вызвать метод ~.value~.

#+begin_src sclang
f = { 1 + 2 };
f.value; // 3
#+end_src

Понятно, что фунции, вроде той, что мы написали выше не особо полезны.
Чтобы написать по настоящему полезную ф-цию, нужно передать ей аргументы.

#+begin_src sclang
f = { arg x; x + 1};
f.value(1); // 2
#+end_src

Также можно задать значение аргумента по-умолчанию.

#+begin_src sclang
f = { arg x = 1; x + 1};
f.value; // 2
#+end_src

Для ф-ций также существует более короткий способ записи и вызова.

#+begin_src sclang
f = { |x| x + 1 };
f.(1); // 2
#+end_src

Его мы будем использовать чаще.

* Юнит-генераторы (Ugen)
Пришло время создать первый звук. Для этого в SC существует множество
строительных блоков - юнит генераторов. Это генераторы тона, огибающей,
триггеры, фильтры и прочее.

Для того, чтобы начать работать со звуком нужно запустить сервер командой
~s.boot;~

#+begin_src sclang
s.boot;

f = { SinOsc.ar(440) }.play;
f.free;
#+end_src

[[https://doc.sccode.org/Classes/SinOsc.html][SinOsc]] - это генератор синусоиды. У любого генератора есть методы ~.ar~ и
~.kr~ - сокращения от Audio rate и Control rate. От выбора параметра зависит
насколько часто генератор будет обновлять значения. Для звука стоит выбирать
~.ar~, для модуляций подойдёт ~.kr~ (есть ещё ~.ir~, но мы не будем его
рассматривать).

Метод ~.play~ создаёт экземпляр класса [[https://doc.sccode.org/Classes/Synth.html][Synth]] у отправляет его на сервер.
Этот синтезатор можно остановить при помощи ~.free~.

Вот пример простого тремоло:

#+begin_src sclang
s.boot;

f = { SinOsc.ar(440) * SinOsc.kr(10).range(0.75, 1) }.play;
f.free;
#+end_src

** Отладка и анализ Юнит-генераторов
Иногда бывает полезно посмотреть какие именно значения выдаёт тот или иной
генератор или какая форма сигнала получается при, например, алгебраических
операциях над ними.

Чтобы вывести в окно отладки значение генератора нужно вызвать у него метод
~.poll~.

#+begin_src sclang
s.boot;

f = { SinOsc.ar(440).poll }.play;
f.free;
#+end_src

В итоге мы увидим следующее:

#+begin_src sclang
UGen(SinOsc): 0.057564
UGen(SinOsc): 0.0575251
UGen(SinOsc): 0.0574862
UGen(SinOsc): 0.0574474
UGen(SinOsc): 0.0574085
UGen(SinOsc): 0.0573696
UGen(SinOsc): 0.0573307
UGen(SinOsc): 0.0572918
UGen(SinOsc): 0.0572529
UGen(SinOsc): 0.0572141
UGen(SinOsc): 0.0571752
#+end_src

Также бывает полезно добавить какую-нибудь метку, например, чтобы лучше
понимать, к какому именно генератору относятся данные. Это можно сделать,
указав аргумент ~label~

#+begin_src sclang
s.boot;

f = {
  SinOsc.ar(440).poll(label: \signal) *
  SinOsc.ar(20).poll(label: \amp_modulation)
}.play;

f.free;
#+end_src

Результат будет информативнее:

#+begin_src sclang
signal: 0.057564
amp_modulation: 0.00261799
signal: 0.0575251
amp_modulation: 0.002606
signal: 0.0574862
amp_modulation: 0.00259402
signal: 0.0574474
amp_modulation: 0.00258204
signal: 0.0574085
amp_modulation: 0.00257005
signal: 0.0573696
amp_modulation: 0.00255807
#+end_src

Также можно вывести форму волны для Юнит-генераторов, функций, коллекций
и даже файлов. Для этого можно вызвать метод ~.plot~.

#+begin_src sclang
(
{ SinOsc.ar(220 * SinOsc.ar(20)) }.plot;
{ SinOsc.ar(440) * SinOsc.ar(20) }.plot;
)
#+end_src


#+CAPTION: Результат печати для первого сигнала
[[./plot_example1.png]]

#+CAPTION: Результат печати для второго сигнала
[[./plot_example2.png]]
